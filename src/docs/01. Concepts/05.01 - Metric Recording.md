---
title: "Metric Recording"
description: "Understanding how metric recording works in Diginsight Components to track database costs and identify expensive operations across your application"
author: "Diginsight Team"
date: "2025-01-08"
categories: ["concepts", "observability", "metrics"]
tags: ["metrics", "opentelemetry", "database-cost", "performance", "monitoring"]
order: 1
---

Metric recording in Diginsight Components provides **automatic capture and analysis of database operation costs**, enabling you to **identify expensive operations**, **track performance trends**, and **optimize resource usage** across your application.

The metric recording system is designed as a **strategic resource for cost management** that enables you to:

- üîç **Identify database cost for every query** with detailed Request Unit (RU) consumption tracking
- üìä **Track costs by caller method** to pinpoint expensive business operations  
- üè∑Ô∏è **Filter by arbitrary tags** (application, customer, report type) for targeted analysis
- üí∞ **Contain expensive executions** through data-driven optimization

## Table of Contents

- [üìã Overview](#-overview)
  - [Core Concepts](#core-concepts)
  - [Key Capabilities](#key-capabilities)
- [üîç How It Works](#-how-it-works)
  - [Automatic Detection](#automatic-detection)
  - [Tag Enrichment](#tag-enrichment)
  - [Query Normalization](#query-normalization)
- [üí° Strategic Use Cases](#-strategic-use-cases)
  - [Database Cost Analysis](#database-cost-analysis)
  - [Performance Optimization](#performance-optimization)
  - [Business Intelligence](#business-intelligence)
- [‚öôÔ∏è Configuration](#Ô∏è-configuration)
  - [Basic Setup](#basic-setup)
  - [Advanced Configuration](#advanced-configuration)
- [üìä Analytics Examples](#-analytics-examples)
  - [Query Cost by Application](#query-cost-by-application)
  - [Top Expensive Operations](#top-expensive-operations)
  - [Cost Trends and Patterns](#cost-trends-and-patterns)
  - [Visual Cost Analysis](#visual-cost-analysis)
- [üîß Customization](#-customization)
  - [Custom Filters](#custom-filters)
  - [Custom Enrichers](#custom-enrichers)
- [üìö Reference](#-reference)

## üìã Overview

### Core Concepts

**Metric Recording** in Diginsight Components works by automatically monitoring OpenTelemetry activities and extracting performance metrics from database operations. When combined with observable database extensions like [`CosmosDbExtensions`](../03.%20Reference/05.02%20-%20CosmosDbExtensions.md), it provides comprehensive cost tracking without requiring manual instrumentation.

The centerpiece of database cost tracking is the [`QueryCostMetricRecorder`](../03.%20Reference/05.01%20-%20QueryCostMetricRecorder.md), which captures **CosmosDB query costs** as the **`diginsight.query_cost`** OpenTelemetry metric.

### Key Capabilities

#### Automatic Cost Tracking

- Records Request Units (RU) consumption for every database operation
- No manual instrumentation required - works with existing Diginsight telemetry
- Captures costs at the individual query level with full context

#### Rich Context Information

- Method names and caller chain analysis
- Database and container information
- Application and environment tagging
- Custom business context through extensible enrichment

#### Intelligent Filtering

- Query normalization to reduce metric cardinality
- Caller filtering to focus on business operations
- Custom filtering logic for specific use cases
- Configurable tag inclusion/exclusion

## üîç How It Works

### Automatic Detection

The metric recording system operates through a sophisticated **activity listening mechanism**:

1. **Activity Monitoring**: Listens to OpenTelemetry activities from database operations
2. **Cost Extraction**: Identifies activities with `query_cost` tags indicating CosmosDB operations  
3. **Context Analysis**: Analyzes the call chain to identify business methods and entry points
4. **Metric Recording**: Records histogram data with enriched tags for analysis

```csharp
// When this CosmosDB operation executes...
var response = await container.ReadItemObservableAsync<User>(userId, new PartitionKey("users"));

// The metric recorder automatically captures:
// - query_cost: 2.45 RU
// - method: "ReadItemObservableAsync"
// - caller1: "UserService.GetUserProfile"
// - application: "MyApp"
// - container: "users"
// - database: "myapp-prod"
```

### Tag Enrichment

Every recorded metric includes comprehensive tagging for detailed analysis:

**Standard Tags (Always Present):**

- `method`: The immediate database operation method
- `entrymethod`: The top-level entry point method  
- `application`: Application name from entry assembly
- `container`: CosmosDB container name (if available)
- `database`: CosmosDB database name (if available)

**Configurable Tags:**

- `query`: Normalized query text (for pattern analysis)
- `caller1`, `caller2`, etc.: Business logic methods in the call chain
- Custom tags through `IMetricRecordingEnricher` implementations

### Query Normalization

Raw queries are normalized to prevent metric cardinality explosion while preserving semantic meaning:

```sql
-- Original query
SELECT * FROM c WHERE c.id = '123e4567-e89b-12d3-a456-426614174000' AND c.timestamp > '2023-01-01T10:30:00Z'

-- Normalized query  
SELECT * FROM c WHERE c.id = '{GUID}' AND c.timestamp > '{DATETIME}'
```

**Caller Filtering:**
Focus metrics on business operations by excluding infrastructure code:

```csharp
// Configuration to surface business operations
options.IgnoreQueryCallers = new[]
{
    "BaseRepository*",           // Skip generic repository methods
    "CosmosDbExtensions.*",      // Skip extension helpers
    "*Middleware*"               // Skip framework middleware
};

// Result: Metrics show business methods like:
// - UserService.GetUserProfile
// - OrderService.ProcessOrder
// Instead of infrastructure methods like:
// - BaseRepository.GetItems
```

## üí° Strategic Use Cases

### Database Cost Analysis

**üéØ Primary Value Proposition**: Identify and contain expensive database operations before they impact your budget.

**Query Cost by Operation Type:**
```csharp
// Track costs by operation to identify expensive patterns
var costsByOperation = metrics
    .Where(m => m.MetricName == "diginsight.query_cost")
    .GroupBy(m => m.Tags["method"])
    .Select(g => new {
        Operation = g.Key,
        TotalCost = g.Sum(m => m.Value),
        AvgCost = g.Average(m => m.Value),
        Count = g.Count()
    })
    .OrderByDescending(x => x.TotalCost);
```

**Cost by Business Function:**
```csharp
// Identify which business operations consume the most resources
var costsByBusinessFunction = metrics
    .Where(m => m.MetricName == "diginsight.query_cost" && m.Tags.ContainsKey("caller1"))
    .GroupBy(m => m.Tags["caller1"])
    .Select(g => new {
        BusinessFunction = g.Key,
        TotalCost = g.Sum(m => m.Value),
        OperationCount = g.Count(),
        AvgCostPerOperation = g.Average(m => m.Value)
    })
    .OrderByDescending(x => x.TotalCost);

// Results might show:
// - ReportService.GenerateAnnualReport: 15,420 RU total
// - UserService.GetUserProfile: 8,730 RU total  
// - OrderService.ProcessBulkOrder: 6,890 RU total
```



### Performance Optimization

**üöÄ Optimization Workflow**:

1. **Identify High-Cost Operations**
   ```csharp
   // Find operations consuming >100 RU on average
   var expensiveOperations = metrics
       .Where(m => m.MetricName == "diginsight.query_cost")
       .GroupBy(m => new { 
           Method = m.Tags["method"], 
           Caller = m.Tags.GetValueOrDefault("caller1", "Unknown") 
       })
       .Where(g => g.Average(m => m.Value) > 100)
       .Select(g => new {
           Operation = $"{g.Key.Caller} -> {g.Key.Method}",
           AvgCost = g.Average(m => m.Value),
           TotalExecutions = g.Count()
       });
   ```

2. **Analyze Query Patterns**
   ```csharp
   // Identify expensive query patterns
   var expensiveQueries = metrics
       .Where(m => m.MetricName == "diginsight.query_cost" && 
                  m.Tags.ContainsKey("query") && 
                  m.Value > 50)
       .GroupBy(m => m.Tags["query"])
       .Select(g => new {
           QueryPattern = g.Key,
           AvgCost = g.Average(m => m.Value),
           MaxCost = g.Max(m => m.Value),
           ExecutionCount = g.Count()
       })
       .OrderByDescending(x => x.AvgCost);
   ```

3. **Track Optimization Impact**
   ```csharp
   // Compare costs before and after optimization
   var beforeOptimization = metrics
       .Where(m => m.Timestamp < optimizationDate)
       .GroupBy(m => m.Tags["caller1"])
       .ToDictionary(g => g.Key, g => g.Average(m => m.Value));
       
   var afterOptimization = metrics
       .Where(m => m.Timestamp >= optimizationDate)
       .GroupBy(m => m.Tags["caller1"])
       .ToDictionary(g => g.Key, g => g.Average(m => m.Value));
   ```

### Business Intelligence

**üìä Strategic Filtering by Arbitrary Tags**:

Metric recording enables powerful business analysis through flexible tagging:

**Filter by Application:**
```csharp
// Compare costs across different applications
var costsByApp = metrics
    .Where(m => m.MetricName == "diginsight.query_cost")
    .GroupBy(m => m.Tags["application"])
    .Select(g => new {
        Application = g.Key,
        TotalCost = g.Sum(m => m.Value),
        DailyCost = g.Sum(m => m.Value) / g.Select(m => m.Timestamp.Date).Distinct().Count()
    });

// Results:
// - CustomerPortal: 45,000 RU/day
// - AdminDashboard: 12,000 RU/day
// - ReportingService: 78,000 RU/day
```

**Filter by Customer (using custom enrichment):**
```csharp
// Custom enricher to add customer context
public class CustomerMetricEnricher : IMetricRecordingEnricher
{
    public IEnumerable<KeyValuePair<string, object?>> ExtractTags(Activity activity)
    {
        // Extract customer ID from activity context
        if (activity.GetCustomProperty("CustomerId") is string customerId)
        {
            yield return new KeyValuePair<string, object?>("customer", customerId);
        }
    }
}

// Analysis by customer
var costsByCustomer = metrics
    .Where(m => m.MetricName == "diginsight.query_cost" && m.Tags.ContainsKey("customer"))
    .GroupBy(m => m.Tags["customer"])
    .Select(g => new {
        Customer = g.Key,
        TotalCost = g.Sum(m => m.Value),
        OperationCount = g.Count(),
        CostPerOperation = g.Average(m => m.Value)
    })
    .OrderByDescending(x => x.TotalCost);
```

**Filter by Report Type:**
```csharp
// Track costs by specific business operations
var reportCosts = metrics
    .Where(m => m.MetricName == "diginsight.query_cost" && 
               m.Tags["caller1"].Contains("ReportService"))
    .GroupBy(m => ExtractReportType(m.Tags["entrymethod"]))
    .Select(g => new {
        ReportType = g.Key,
        TotalCost = g.Sum(m => m.Value),
        ExecutionCount = g.Count(),
        AvgCostPerReport = g.Average(m => m.Value)
    });

// Results might show:
// - AnnualFinancialReport: 2,340 RU avg (5 executions)
// - DailyUserActivity: 45 RU avg (1,200 executions)  
// - MonthlyCustomerAnalysis: 890 RU avg (30 executions)
```

## ‚öôÔ∏è Configuration

### Basic Setup

**1. Register the Query Cost Metric Recorder:**

```csharp
// Program.cs
var builder = WebApplication.CreateBuilder(args);

// Add Diginsight observability
builder.Services.AddObservability();

// Add query cost metric recording
builder.Services.AddCosmosDbQueryCostMetricRecorder();

// Configure OpenTelemetry to export metrics
builder.Services.AddOpenTelemetry()
    .WithMetrics(builder => builder.AddMeter("Diginsight.Components.Azure"));

var app = builder.Build();
```

**2. Use Observable CosmosDB Extensions:**

```csharp
// Replace standard CosmosDB methods with observable versions
public class UserRepository
{
    private readonly Container _container;

    public async Task<User> GetUserAsync(string userId)
    {
        // Standard: var response = await _container.ReadItemAsync<User>(userId, new PartitionKey("users"));
        // Observable: 
        var response = await _container.ReadItemObservableAsync<User>(userId, new PartitionKey("users"));
        return response.Resource;
    }

    public async Task<List<User>> GetActiveUsersAsync()
    {
        // Standard: var iterator = _container.GetItemQueryIterator<User>("SELECT * FROM c WHERE c.Status = 'Active'");
        // Observable:
        var iterator = _container.GetItemQueryIteratorObservable<User>("SELECT * FROM c WHERE c.Status = 'Active'");
        
        var users = new List<User>();
        while (iterator.HasMoreResults)
        {
            var response = await iterator.ReadNextAsync();
            users.AddRange(response);
        }
        return users;
    }
}
```

### Advanced Configuration

**Configure Metric Recording Options:**

```csharp
services.Configure<QueryCostMetricRecorderOptions>(options =>
{
    // Include normalized query patterns in metrics (default: false)
    options.AddNormalizedQueryTag = true;
    options.NormalizedQueryMaxLen = 200;
    
    // Include caller method context (0-5, default: 0)
    options.AddQueryCallers = 2;
    
    // Skip infrastructure methods to surface business operations
    options.IgnoreQueryCallers = new[]
    {
        "BaseRepository*",        // Skip generic repository methods
        "CosmosDbExtensions.*",   // Skip extension helpers
        "*Middleware*",           // Skip framework middleware
        "System.*"                // Skip system methods
    };
});
```

**appsettings.json Configuration:**

```json
{
  "QueryCostMetricRecorderOptions": {
    "AddNormalizedQueryTag": true,
    "NormalizedQueryMaxLen": 300,
    "AddQueryCallers": 2,
    "IgnoreQueryCallers": [
      "BaseRepository*",
      "CosmosDbExtensions.*",
      "*Controller*"
    ]
  },
  "Logging": {
    "LogLevel": {
      "Diginsight.Components.Azure.Metrics": "Information"
    }
  }
}
```

## üìä Analytics Examples

### Query Cost by Application

**Track database costs across multiple applications:**

```csharp
// Metrics query to analyze costs by application
var applicationCosts = await metricsQuery
    .Where(m => m.Name == "diginsight.query_cost")
    .GroupBy(m => m.Tags["application"])
    .Select(g => new {
        Application = g.Key,
        TotalCost = g.Sum(m => m.Value),
        OperationCount = g.Count(),
        AvgCostPerOperation = g.Average(m => m.Value),
        P95Cost = g.OrderByDescending(m => m.Value).Skip((int)(g.Count() * 0.05)).First().Value
    })
    .OrderByDescending(x => x.TotalCost)
    .ToListAsync();

// Example results:
// Application          | Total RU | Operations | Avg RU | P95 RU
// -------------------- | -------- | ---------- | ------ | ------
// ReportingService     | 125,430  | 2,456      | 51.1   | 234.7
// CustomerPortal       | 89,760   | 15,678     | 5.7    | 23.4
// AdminDashboard       | 34,210   | 8,934      | 3.8    | 15.2
```

### Top Expensive Operations

**Identify the most costly database operations:**

```csharp
// Find operations with highest individual costs
var topExpensiveOperations = await metricsQuery
    .Where(m => m.Name == "diginsight.query_cost")
    .GroupBy(m => new { 
        Method = m.Tags["method"],
        Caller = m.Tags.GetValueOrDefault("caller1", "Unknown"),
        Container = m.Tags.GetValueOrDefault("container", "Unknown")
    })
    .Select(g => new {
        Operation = $"{g.Key.Caller} ‚Üí {g.Key.Method}",
        Container = g.Key.Container,
        MaxCost = g.Max(m => m.Value),
        AvgCost = g.Average(m => m.Value),
        TotalExecutions = g.Count(),
        TotalCost = g.Sum(m => m.Value)
    })
    .OrderByDescending(x => x.MaxCost)
    .Take(10)
    .ToListAsync();

// Example output:
// Operation                                    | Container | Max RU | Avg RU | Executions | Total RU
// -------------------------------------------- | --------- | ------ | ------ | ---------- | --------
// ReportService.GenerateAnnualReport ‚Üí Query  | reports   | 2,340  | 1,890  | 12         | 22,680
// AnalyticsService.GetCustomerTrends ‚Üí Query   | analytics | 1,567  | 1,234  | 45         | 55,530
// UserService.GetUserHistory ‚Üí Query          | users     | 890    | 456    | 234        | 106,704
```

### Cost Trends and Patterns

**Track cost trends over time:**

```csharp
// Daily cost trends by application
var dailyCostTrends = await metricsQuery
    .Where(m => m.Name == "diginsight.query_cost" && 
               m.Timestamp >= DateTime.UtcNow.AddDays(-30))
    .GroupBy(m => new { 
        Date = m.Timestamp.Date,
        Application = m.Tags["application"]
    })
    .Select(g => new {
        Date = g.Key.Date,
        Application = g.Key.Application,
        DailyCost = g.Sum(m => m.Value),
        OperationCount = g.Count()
    })
    .OrderBy(x => x.Date)
    .ToListAsync();

// Peak usage analysis
var peakUsageHours = await metricsQuery
    .Where(m => m.Name == "diginsight.query_cost" && 
               m.Timestamp >= DateTime.UtcNow.AddDays(-7))
    .GroupBy(m => m.Timestamp.Hour)
    .Select(g => new {
        Hour = g.Key,
        TotalCost = g.Sum(m => m.Value),
        OperationCount = g.Count(),
        AvgCostPerHour = g.Sum(m => m.Value) / 7 // 7 days
    })
    .OrderByDescending(x => x.TotalCost)
    .ToListAsync();
```

**Query Pattern Analysis:**

```csharp
// Analyze which query patterns are most expensive
var queryPatternCosts = await metricsQuery
    .Where(m => m.Name == "diginsight.query_cost" && 
               m.Tags.ContainsKey("query"))
    .GroupBy(m => m.Tags["query"])
    .Select(g => new {
        QueryPattern = g.Key,
        ExecutionCount = g.Count(),
        TotalCost = g.Sum(m => m.Value),
        AvgCost = g.Average(m => m.Value),
        MaxCost = g.Max(m => m.Value),
        Applications = g.Select(m => m.Tags["application"]).Distinct().ToList()
    })
    .Where(x => x.ExecutionCount > 10) // Focus on frequently executed queries
    .OrderByDescending(x => x.TotalCost)
    .ToListAsync();

// Example results showing expensive query patterns:
// Pattern: "SELECT * FROM c WHERE c.customerId = {GUID} AND c.date BETWEEN {DATETIME} AND {DATETIME}"
// - Total Cost: 45,670 RU
// - Executions: 1,234
// - Avg Cost: 37.0 RU
// - Used by: CustomerPortal, ReportingService
```

### Visual Cost Analysis

**ASCII Bar Chart for Method Costs:**
Here's how to create a visual representation of database costs by method using simple ASCII characters:

```csharp
// Generate cost data by method
var methodCosts = await metricsQuery
    .Where(m => m.Name == "diginsight.query_cost")
    .GroupBy(m => m.Tags["caller1"] ?? m.Tags["method"])
    .Select(g => new {
        Method = g.Key,
        TotalCost = g.Sum(m => m.Value),
        AvgCost = g.Average(m => m.Value),
        Count = g.Count()
    })
    .OrderByDescending(x => x.TotalCost)
    .Take(15)
    .ToListAsync();

// Create ASCII bar chart
public static string CreateCostBarChart(IEnumerable<dynamic> methodCosts, int maxWidth = 50)
{
    var sb = new StringBuilder();
    var costs = methodCosts.ToList();
    var maxCost = costs.Max(x => (double)x.TotalCost);
    
    sb.AppendLine("Database Cost by Method (Total RU)");
    sb.AppendLine("".PadRight(80, '='));
    sb.AppendLine();
    
    foreach (var item in costs)
    {
        var method = ((string)item.Method).Length > 35 
            ? ((string)item.Method).Substring(0, 32) + "..." 
            : ((string)item.Method).PadRight(35);
            
        var cost = (double)item.TotalCost;
        var barLength = (int)((cost / maxCost) * maxWidth);
        var bar = "‚ñà".PadRight(barLength, '‚ñà');
        
        sb.AppendLine($"{method} ‚îÇ{bar} {cost:N0} RU ({item.Count} ops)");
    }
    
    sb.AppendLine();
    sb.AppendLine($"Scale: Each ‚ñà ‚âà {maxCost/maxWidth:N0} RU");
    
    return sb.ToString();
}
```

**Example Output:**
```
Database Cost by Method (Total RU)
================================================================================

ReportService.GenerateAnnualReport  ‚îÇ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 15,420 RU (12 ops)
UserService.GetUserProfile          ‚îÇ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà               8,730 RU (1,234 ops)
AnalyticsService.GetCustomerTrends  ‚îÇ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà                       6,234 RU (156 ops)
ProductService.SearchProducts       ‚îÇ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà                            4,567 RU (2,345 ops)
CustomerService.GetCustomerHistory  ‚îÇ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà                                 3,234 RU (567 ops)
NotificationService.SendBulkEmail   ‚îÇ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà                                     2,345 RU (89 ops)
PaymentService.ProcessRefund        ‚îÇ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà                                         1,789 RU (123 ops)
UserService.UpdateProfile           ‚îÇ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà                                           1,456 RU (2,345 ops)
ProductService.GetProductDetails    ‚îÇ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà                                             1,234 RU (3,456 ops)
OrderService.GetOrderStatus         ‚îÇ‚ñà‚ñà‚ñà‚ñà                                                 890 RU (4,567 ops)
CustomerService.SearchCustomers     ‚îÇ‚ñà‚ñà‚ñà                                                  675 RU (1,789 ops)

Scale: Each ‚ñà ‚âà 308 RU
```

**Enhanced Visualization with Cost Efficiency:**
```csharp
public static string CreateCostEfficiencyChart(IEnumerable<dynamic> methodCosts, int maxWidth = 40)
{
    var sb = new StringBuilder();
    var costs = methodCosts.ToList();
    var maxAvgCost = costs.Max(x => (double)x.AvgCost);
    
    sb.AppendLine("Database Cost Efficiency Analysis");
    sb.AppendLine("".PadRight(85, '='));
    sb.AppendLine($"{"Method",-35} ‚îÇ {"Avg RU",-8} ‚îÇ {"Total RU",-8} ‚îÇ {"Ops",-5} ‚îÇ Efficiency");
    sb.AppendLine("".PadRight(85, '-'));
    
    foreach (var item in costs)
    {
        var method = ((string)item.Method).Length > 32 
            ? ((string)item.Method).Substring(0, 29) + "..." 
            : ((string)item.Method);
            
        var avgCost = (double)item.AvgCost;
        var totalCost = (double)item.TotalCost;
        var count = (int)item.Count;
        
        // Efficiency indicator: Low avg cost = good efficiency
        var efficiencyLevel = avgCost switch
        {
            <= 5.0 => "üü¢ Excellent",
            <= 25.0 => "üü° Good    ",
            <= 100.0 => "üü† Moderate",
            _ => "üî¥ Poor    "
        };
        
        var barLength = Math.Max(1, (int)((avgCost / maxAvgCost) * maxWidth));
        var bar = "‚ñì".PadRight(barLength, '‚ñì');
        
        sb.AppendLine($"{method,-35} ‚îÇ {avgCost,8:N1} ‚îÇ {totalCost,8:N0} ‚îÇ {count,5:N0} ‚îÇ {efficiencyLevel}");
    }
    
    sb.AppendLine();
    sb.AppendLine("Efficiency Levels: üü¢ ‚â§5 RU  üü° ‚â§25 RU  üü† ‚â§100 RU  üî¥ >100 RU");
    
    return sb.ToString();
}
```

**Example Efficiency Analysis Output:**
```
Database Cost Efficiency Analysis
=====================================================================================
Method                              ‚îÇ  Avg RU ‚îÇ Total RU ‚îÇ   Ops ‚îÇ Efficiency
-------------------------------------------------------------------------------------
ReportService.GenerateAnnualReport  ‚îÇ   1285.0 ‚îÇ   15,420 ‚îÇ    12 ‚îÇ üî¥ Poor    
AnalyticsService.GetCustomerTrends  ‚îÇ     39.9 ‚îÇ    6,234 ‚îÇ   156 ‚îÇ üü† Moderate
OrderService.ProcessBulkOrder       ‚îÇ    153.1 ‚îÇ    6,890 ‚îÇ    45 ‚îÇ üî¥ Poor    
InvoiceService.GenerateInvoice      ‚îÇ     16.6 ‚îÇ    3,890 ‚îÇ   234 ‚îÇ üü° Good    
UserService.GetUserProfile          ‚îÇ      7.1 ‚îÇ    8,730 ‚îÇ 1,234 ‚îÇ üü° Good    
CustomerService.GetCustomerHistory  ‚îÇ      5.7 ‚îÇ    3,234 ‚îÇ   567 ‚îÇ üü° Good    
NotificationService.SendBulkEmail   ‚îÇ     26.3 ‚îÇ    2,345 ‚îÇ    89 ‚îÇ üü† Moderate
AuditService.GetAuditTrail          ‚îÇ      6.1 ‚îÇ    2,123 ‚îÇ   345 ‚îÇ üü° Good    
PaymentService.ProcessRefund        ‚îÇ     14.6 ‚îÇ    1,789 ‚îÇ   123 ‚îÇ üü° Good    
InventoryService.UpdateStock        ‚îÇ      2.0 ‚îÇ    2,890 ‚îÇ 1,456 ‚îÇ üü¢ Excellent
UserService.UpdateProfile           ‚îÇ      0.6 ‚îÇ    1,456 ‚îÇ 2,345 ‚îÇ üü¢ Excellent
ProductService.GetProductDetails    ‚îÇ      0.4 ‚îÇ    1,234 ‚îÇ 3,456 ‚îÇ üü¢ Excellent
OrderService.GetOrderStatus         ‚îÇ      0.2 ‚îÇ      890 ‚îÇ 4,567 ‚îÇ üü¢ Excellent
CustomerService.SearchCustomers     ‚îÇ      0.4 ‚îÇ      675 ‚îÇ 1,789 ‚îÇ üü¢ Excellent

Efficiency Levels: üü¢ ‚â§5 RU  üü° ‚â§25 RU  üü† ‚â§100 RU  üî¥ >100 RU
```

This visual representation makes it immediately clear which methods need optimization attention:

- **üî¥ Poor efficiency** methods like `ReportService.GenerateAnnualReport` (1,285 RU avg) are prime candidates for optimization
- **üü¢ Excellent efficiency** methods like basic CRUD operations show healthy patterns
- The visualization helps prioritize optimization efforts based on both total cost and efficiency

## üîß Customization

### Custom Filters

**Create Custom Metric Filters:**

```csharp
// Filter to exclude certain operations from metrics
public class CustomMetricFilter : IMetricRecordingFilter
{
    public bool ShouldRecord(Activity activity)
    {
        // Skip health check operations
        if (activity.GetCustomProperty("IsHealthCheck") is bool isHealthCheck && isHealthCheck)
            return false;
            
        // Skip operations with very low cost (noise reduction)
        if (activity.GetCustomProperty("query_cost") is double cost && cost < 1.0)
            return false;
            
        // Skip operations from specific methods
        var method = activity.OperationName;
        if (method?.Contains("Ping") == true || method?.Contains("Echo") == true)
            return false;
            
        return true;
    }
}

// Register the custom filter
services.AddSingleton<IMetricRecordingFilter, CustomMetricFilter>();
```

### Custom Enrichers

**Add Custom Business Context:**

```csharp
// Enricher to add tenant/customer information
public class TenantMetricEnricher : IMetricRecordingEnricher
{
    private readonly IHttpContextAccessor _httpContextAccessor;
    
    public TenantMetricEnricher(IHttpContextAccessor httpContextAccessor)
    {
        _httpContextAccessor = httpContextAccessor;
    }
    
    public IEnumerable<KeyValuePair<string, object?>> ExtractTags(Activity activity)
    {
        var httpContext = _httpContextAccessor.HttpContext;
        if (httpContext == null) yield break;
        
        // Extract tenant ID from header or claims
        if (httpContext.Request.Headers.TryGetValue("X-Tenant-Id", out var tenantId))
        {
            yield return new KeyValuePair<string, object?>("tenant", tenantId.ToString());
        }
        
        // Extract user ID from claims
        var userId = httpContext.User?.FindFirst("sub")?.Value;
        if (!string.IsNullOrEmpty(userId))
        {
            yield return new KeyValuePair<string, object?>("user", userId);
        }
        
        // Extract feature flag information
        if (activity.GetCustomProperty("FeatureFlags") is Dictionary<string, bool> features)
        {
            foreach (var feature in features.Where(f => f.Value))
            {
                yield return new KeyValuePair<string, object?>($"feature_{feature.Key}", true);
            }
        }
        
        // Extract request context
        var requestPath = httpContext.Request.Path.Value;
        if (requestPath?.StartsWith("/api/reports/") == true)
        {
            var reportType = ExtractReportTypeFromPath(requestPath);
            if (!string.IsNullOrEmpty(reportType))
            {
                yield return new KeyValuePair<string, object?>("report_type", reportType);
            }
        }
    }
    
    private string? ExtractReportTypeFromPath(string path)
    {
        // Extract report type from API path like "/api/reports/financial/annual"
        var segments = path.Split('/', StringSplitOptions.RemoveEmptyEntries);
        return segments.Length >= 4 ? $"{segments[2]}_{segments[3]}" : null;
    }
}

// Register the custom enricher
services.AddSingleton<IMetricRecordingEnricher, TenantMetricEnricher>();
services.AddHttpContextAccessor(); // Required for HTTP context access
```

**Advanced Enrichment with Business Logic:**
```csharp
// Enricher that adds cost classification
public class CostClassificationEnricher : IMetricRecordingEnricher
{
    public IEnumerable<KeyValuePair<string, object?>> ExtractTags(Activity activity)
    {
        if (activity.GetCustomProperty("query_cost") is not double cost)
            yield break;
            
        // Classify operations by cost
        var costTier = cost switch
        {
            < 5.0 => "low",
            < 25.0 => "medium", 
            < 100.0 => "high",
            _ => "critical"
        };
        
        yield return new KeyValuePair<string, object?>("cost_tier", costTier);
        
        // Add efficiency rating based on operation type
        var method = activity.OperationName;
        if (method?.Contains("ReadItem") == true && cost > 10.0)
        {
            yield return new KeyValuePair<string, object?>("efficiency", "inefficient_read");
        }
        else if (method?.Contains("Query") == true && cost > 50.0)
        {
            yield return new KeyValuePair<string, object?>("efficiency", "expensive_query");
        }
    }
}
```

## üìö Reference

### Key Components

- **[`QueryCostMetricRecorder`](../03.%20Reference/05.01%20-%20QueryCostMetricRecorder.md)**: Core component that captures CosmosDB query costs
- **[`CosmosDbExtensions`](../03.%20Reference/05.02%20-%20CosmosDbExtensions.md)**: Observable database operations that generate cost telemetry
- **`IMetricRecordingFilter`**: Interface for custom filtering logic
- **`IMetricRecordingEnricher`**: Interface for custom tag enrichment

### Metric Structure

**Metric Name**: `diginsight.query_cost`
**Type**: Histogram
**Unit**: Request Units (RU)
**Description**: "CosmosDB query cost in Request Units"

**Standard Tags**:
- `method`: Database operation method
- `entrymethod`: Top-level entry point  
- `application`: Application name
- `container`: CosmosDB container (if available)
- `database`: CosmosDB database (if available)

**Configurable Tags**:
- `query`: Normalized query text
- `caller1`, `caller2`, etc.: Business method callers
- Custom tags via enrichers

### Configuration Options

```csharp
public class QueryCostMetricRecorderOptions
{
    public bool AddNormalizedQueryTag { get; set; } = false;
    public int AddQueryCallers { get; set; } = 0;
    public string[] IgnoreQueryCallers { get; set; } = Array.Empty<string>();
    public int NormalizedQueryMaxLen { get; set; } = 500;
}
```

### Best Practices

**‚úÖ Do:**
- Use normalized queries to reduce cardinality
- Configure caller filtering to surface business operations
- Implement custom enrichers for business context
- Monitor high-cost operations and trends
- Set up alerts for cost anomalies

**‚ùå Don't:**
- Enable detailed query logging in production without limits
- Include high-cardinality data in custom tags
- Record metrics for health checks or internal operations
- Ignore the performance impact of extensive enrichment

---

> **üí° Pro Tip**: Start with basic configuration and gradually add enrichment based on your specific analysis needs. The power of metric recording lies in its ability to provide **strategic insights into your database costs** and help you **make data-driven optimization decisions**.

