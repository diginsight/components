---
title: "TimeSpanParser Class"
subtitle: "Extended duration parsing with calendar-based units and human-readable formats"
author: "Diginsight Components"
date: last-modified
categories: 
  - reference
  - time
  - duration
  - parsing
  - calendar
format:
  html:
    toc: true
    toc-depth: 4
    toc-location: left
    code-fold: false
    code-tools: true
    code-line-numbers: true
    highlight-style: github
    theme: cosmo
    css: styles.css
execute:
  echo: true
  eval: false
---

The `TimeSpanParser` provides **extended duration parsing** with support for **calendar-based units** like years and months that cannot be precisely represented as fixed TimeSpans.

In particular, it enables **human-readable duration expressions** (e.g., "6M", "1.5Y", "2W3D") while maintaining backward compatibility with standard `TimeSpan.Parse` formats.

`TimeSpanParser` is part of **Diginsight.Components**.

The parser supports both **approximate TimeSpan conversions** for simple duration needs and **calendar-accurate date calculations** for precise date arithmetic.

## Table of Contents

- [ðŸ“‹ Overview](#-overview)
  - [Key Features](#key-features)
  - [Supported Units](#supported-units)
- [ðŸ” Additional Details](#-additional-details)
  - [Approximate vs Calendar-Accurate Calculations](#approximate-vs-calendar-accurate-calculations)
  - [Fractional Values](#fractional-values)
  - [Case Sensitivity](#case-sensitivity)
  - [Backward Compatibility](#backward-compatibility)
  - [Unit Ordering](#unit-ordering)
- [âš™ï¸ Configuration](#ï¸-configuration)
  - [Default Period](#default-period)
  - [Conversion Factors](#conversion-factors)
- [ðŸ’¡ Usage Examples](#-usage-examples)
  - [Basic Parsing](#basic-parsing)
  - [Calendar-Accurate Date Calculations](#calendar-accurate-date-calculations)
  - [Safe Parsing with TryParse](#safe-parsing-with-tryparse)
  - [Complex Duration Expressions](#complex-duration-expressions)
  - [Using Predefined Examples](#using-predefined-examples)
- [ðŸ”§ Troubleshooting](#-troubleshooting)
  - [Common Issues](#common-issues)
  - [Parsing Errors](#parsing-errors)
  - [Precision Considerations](#precision-considerations)
- [ðŸ“š Reference](#-reference)
  - [Classes](#classes)
  - [Methods](#methods)
  - [Constants](#constants)
  - [Expression Format](#expression-format)
- [ðŸ’¡ Best Practices](#-best-practices)
  - [Choosing Parse vs GetExpressionOccurrence](#choosing-parse-vs-getexpressionoccurrence)
  - [Handling User Input](#handling-user-input)
  - [Precision Requirements](#precision-requirements)

## ðŸ“‹ Overview

The `TimeSpanParser` extends standard .NET TimeSpan functionality by supporting calendar-based duration units (years and months) that have variable lengths. It provides a simple, human-readable syntax for expressing durations while offering both approximate TimeSpan conversions and calendar-accurate date arithmetic.

### Key Features

- **Calendar-Based Units**: Support for years (Y) and months (M) in addition to standard TimeSpan units
- **Human-Readable Format**: Intuitive expression syntax (e.g., "6M", "1.5Y", "2W3D")
- **Fractional Values**: Decimal support for all time units (e.g., "1.5Y", "2.5M")
- **Dual Calculation Modes**: Both approximate TimeSpan conversion and calendar-accurate date calculations
- **Backward Compatible**: Falls back to standard `TimeSpan.Parse` for compatibility
- **Case Insensitive**: Accepts both uppercase and lowercase unit identifiers
- **Safe Parsing**: `TryParse` method for error-free parsing scenarios
- **Predefined Examples**: Built-in constants for common duration patterns

### Supported Units

The parser supports the following time units in descending order:

| Unit | Identifier | Example | Description |
|------|------------|---------|-------------|
| **Years** | Y | "1Y", "1.5Y" | Calendar years (365.25 days average) |
| **Months** | M | "6M", "2.5M" | Calendar months (30.44 days average) |
| **Weeks** | W | "2W", "1.5W" | Weeks (7 days) |
| **Days** | D | "30D", "1.5D" | Days (24 hours) |
| **Hours** | H | "12H", "0.5H" | Hours (60 minutes) |
| **Minutes** | m | "30m", "1.5m" | Minutes (60 seconds) |
| **Seconds** | S | "45S", "1.5S" | Seconds |

**Example expressions**: "6M", "1.5Y", "2W3D", "1Y6M2W1D12H30m45S"

## ðŸ” Additional Details

### Approximate vs Calendar-Accurate Calculations

The `TimeSpanParser` provides two different calculation approaches depending on your needs:

**Approximate TimeSpan Conversion** (`Parse` method):
- Converts all units to a single `TimeSpan` using average values
- 1 year = 365.25 days (accounts for leap years)
- 1 month = 30.44 days (365.25 / 12)
- Best for: Duration measurements, timeouts, intervals, approximate comparisons

**Calendar-Accurate Calculation** (`GetExpressionOccurrence` method):
- Uses `DateTimeOffset.AddYears` and `AddMonths` for precise calendar arithmetic
- Properly handles varying month lengths (28-31 days)
- Correctly accounts for leap years
- Best for: Billing cycles, subscription renewals, date-based calculations

```csharp
// Approximate: Always returns same TimeSpan
var duration = TimeSpanParser.Parse("1M");  // ~30.44 days

// Calendar-accurate: Respects actual month length
var jan31 = new DateTimeOffset(2024, 1, 31, 0, 0, 0, TimeSpan.Zero);
var result = TimeSpanParser.GetExpressionOccurrence(jan31, "1M", 1);
// Result: December 31, 2023 (31 days back)

var mar31 = new DateTimeOffset(2024, 3, 31, 0, 0, 0, TimeSpan.Zero);
var result2 = TimeSpanParser.GetExpressionOccurrence(mar31, "1M", 1);
// Result: February 29, 2024 (29 days back - leap year)
```

### Fractional Values

All time units support fractional (decimal) values:

```csharp
// Fractional years converted to months
var oneAndHalfYears = TimeSpanParser.Parse("1.5Y");
// Equivalent to: 1 year + 6 months

// Fractional months converted to days
var twoAndHalfMonths = TimeSpanParser.Parse("2.5M");
// Equivalent to: 2 months + ~15 days

// Fractional smaller units
var oneAndHalfWeeks = TimeSpanParser.Parse("1.5W");
// Equivalent to: 10.5 days
```

**Conversion Rules:**
- Fractional years â†’ converted to whole months (1.5Y â†’ 1Y + 6M)
- Fractional months â†’ converted to days using 30.44 days/month
- Fractional weeks, days, hours, minutes, seconds â†’ converted directly

### Case Sensitivity

The parser is **case-insensitive** for all unit identifiers except minutes:

```csharp
// All equivalent
TimeSpanParser.Parse("6M");   // 6 months
TimeSpanParser.Parse("6m");   // 6 MINUTES (lowercase m = minutes!)
TimeSpanParser.Parse("1Y");   // 1 year
TimeSpanParser.Parse("1y");   // 1 year

// Important distinction:
// M (uppercase) = Months
// m (lowercase) = Minutes
```

**Best Practice:** Use uppercase for clarity, except for minutes which should be lowercase 'm'.

### Backward Compatibility

The parser maintains full compatibility with standard `TimeSpan.Parse`:

```csharp
// Standard TimeSpan formats work
var ts1 = TimeSpanParser.Parse("01:30:00");        // 1 hour 30 minutes
var ts2 = TimeSpanParser.Parse("1.12:30:00");      // 1 day, 12 hours, 30 minutes
var ts3 = TimeSpanParser.Parse("00:00:45");        // 45 seconds

// Extended formats
var ts4 = TimeSpanParser.Parse("6M");              // ~6 months
var ts5 = TimeSpanParser.Parse("1Y6M");            // ~1.5 years
```

The parser attempts standard `TimeSpan.Parse` first, then falls back to extended format parsing if that fails.

### Unit Ordering

Units **must appear in descending order** (largest to smallest):

```csharp
// âœ“ Correct ordering
TimeSpanParser.Parse("1Y6M2W3D12H30m45S");

// âœ— Incorrect ordering (will fail to parse)
TimeSpanParser.Parse("6M1Y");     // Months before years
TimeSpanParser.Parse("3D2W");     // Days before weeks
TimeSpanParser.Parse("45S30m");   // Seconds before minutes

// âœ“ You can skip units
TimeSpanParser.Parse("1Y3D");     // Year and days (skipping months and weeks)
TimeSpanParser.Parse("2W12H");    // Weeks and hours (skipping days)
```

## âš™ï¸ Configuration

### Default Period

When no expression is provided or the expression is null/whitespace, the parser uses a default period:

```csharp
public const string DefaultPeriod = "1M";  // 1 month

// These all return 1 month duration
var default1 = TimeSpanParser.Parse(null);
var default2 = TimeSpanParser.Parse("");
var default3 = TimeSpanParser.Parse("   ");
```

You can reference this constant in your code:

```csharp
var configuredPeriod = configuration["RetentionPeriod"] 
    ?? TimeSpanParser.DefaultPeriod;
var retention = TimeSpanParser.Parse(configuredPeriod);
```

### Conversion Factors

The parser uses the following conversion factors for approximate calculations:

| Unit | Days Equivalent | Notes |
|------|----------------|-------|
| Year | 365.25 | Accounts for leap years (Julian year) |
| Month | 30.44 | Average month length (365.25 / 12) |
| Week | 7 | Fixed |
| Day | 1 | Base unit |

These factors are used internally by the `Parse` method. The `GetExpressionOccurrence` method uses calendar-accurate operations instead.

## ðŸ’¡ Usage Examples

### Basic Parsing

```csharp
using Diginsight.Components;

public class RetentionPolicyService
{
    public void ConfigureRetention(string retentionExpression)
    {
        // Parse various duration formats
        var sixMonths = TimeSpanParser.Parse("6M");
        var oneYear = TimeSpanParser.Parse("1Y");
        var twoWeeks = TimeSpanParser.Parse("2W");
        var thirtyDays = TimeSpanParser.Parse("30D");
        
        Console.WriteLine($"6M = {sixMonths.TotalDays:F1} days");  // ~182.6 days
        Console.WriteLine($"1Y = {oneYear.TotalDays:F1} days");    // ~365.25 days
        Console.WriteLine($"2W = {twoWeeks.TotalDays:F1} days");   // 14.0 days
        Console.WriteLine($"30D = {thirtyDays.TotalDays:F1} days"); // 30.0 days
    }
    
    public bool IsExpired(DateTime createdDate, string retentionPeriod)
    {
        var retention = TimeSpanParser.Parse(retentionPeriod);
        return DateTime.UtcNow - createdDate > retention;
    }
}
```

### Calendar-Accurate Date Calculations

```csharp
public class SubscriptionService
{
    public DateTimeOffset CalculateRenewalDate(
        DateTimeOffset startDate, 
        string billingCycle)
    {
        // Calculate exact renewal date using calendar-accurate arithmetic
        // This properly handles month-end dates and leap years
        var renewalDate = TimeSpanParser.GetExpressionOccurrence(
            startDate, 
            billingCycle, 
            occurrence: 1
        );
        
        return renewalDate;
    }
    
    public List<DateTimeOffset> GetBillingDates(
        DateTimeOffset startDate, 
        string billingCycle, 
        int numberOfBillings)
    {
        var dates = new List<DateTimeOffset>();
        
        for (int i = 0; i < numberOfBillings; i++)
        {
            var billingDate = TimeSpanParser.GetExpressionOccurrence(
                startDate.AddMonths(i), 
                billingCycle, 
                occurrence: 1
            );
            dates.Add(billingDate);
        }
        
        return dates;
    }
    
    public void DemonstrateDateAccuracy()
    {
        var startDate = new DateTimeOffset(2024, 1, 31, 0, 0, 0, TimeSpan.Zero);
        
        // Monthly billing on Jan 31
        var feb = TimeSpanParser.GetExpressionOccurrence(startDate, "1M", 1);
        // Result: Dec 31, 2023 (goes back 1 month accurately)
        
        var mar = TimeSpanParser.GetExpressionOccurrence(
            new DateTimeOffset(2024, 3, 31, 0, 0, 0, TimeSpan.Zero), 
            "1M", 
            1
        );
        // Result: Feb 29, 2024 (handles leap year correctly)
    }
}
```

### Safe Parsing with TryParse

```csharp
public class ConfigurationService
{
    private readonly ILogger<ConfigurationService> _logger;
    
    public TimeSpan GetRetentionPeriod(string userInput)
    {
        if (TimeSpanParser.TryParse(userInput, out var duration))
        {
            _logger.LogInformation(
                "Parsed retention period: {Expression} = {Days} days", 
                userInput, 
                duration.TotalDays
            );
            return duration;
        }
        
        _logger.LogWarning(
            "Invalid retention expression: {Expression}, using default", 
            userInput
        );
        return TimeSpanParser.Parse(TimeSpanParser.DefaultPeriod);
    }
    
    public void ValidateUserInput(string input)
    {
        if (!TimeSpanParser.TryParse(input, out var result))
        {
            throw new ArgumentException(
                $"Invalid duration format: '{input}'. " +
                $"Use format like '6M', '1Y', or '2W3D'."
            );
        }
        
        // Further validation
        if (result.TotalDays < 1)
        {
            throw new ArgumentException("Duration must be at least 1 day");
        }
        
        if (result.TotalDays > 3650) // ~10 years
        {
            throw new ArgumentException("Duration cannot exceed 10 years");
        }
    }
}
```

### Complex Duration Expressions

```csharp
public class DurationExamples
{
    public void ComplexExpressions()
    {
        // Combine multiple units
        var complex1 = TimeSpanParser.Parse("1Y6M2W3D");
        // 1 year + 6 months + 2 weeks + 3 days
        
        var complex2 = TimeSpanParser.Parse("1Y6M2W1D12H30m45S");
        // All units combined
        
        var complex3 = TimeSpanParser.Parse("2W3D12H");
        // Skip some units (no years/months)
        
        // Fractional values
        var fractional1 = TimeSpanParser.Parse("1.5Y");   // 1.5 years
        var fractional2 = TimeSpanParser.Parse("2.5M");   // 2.5 months
        var fractional3 = TimeSpanParser.Parse("1.5W3D"); // 1.5 weeks + 3 days
        
        // Comparison: approximate vs actual days
        var sixMonthsApprox = TimeSpanParser.Parse("6M");
        Console.WriteLine($"6M â‰ˆ {sixMonthsApprox.TotalDays:F1} days");
        
        // For actual calculations, use GetExpressionOccurrence
        var today = DateTimeOffset.UtcNow;
        var sixMonthsAgo = TimeSpanParser.GetExpressionOccurrence(today, "6M", 1);
        var actualDays = (today - sixMonthsAgo).TotalDays;
        Console.WriteLine($"6M actual = {actualDays:F1} days (calendar-accurate)");
    }
}
```

### Using Predefined Examples

```csharp
public class ExampleUsage
{
    public void UsePredefinedExamples()
    {
        // Use built-in example constants
        var sixMonths = TimeSpanParser.Parse(TimeSpanParser.Examples.SixMonths);
        var oneHalfYear = TimeSpanParser.Parse(TimeSpanParser.Examples.OneAndHalfYears);
        var sixWeeks = TimeSpanParser.Parse(TimeSpanParser.Examples.SixWeeks);
        
        // In configuration or documentation
        var exampleFormats = new[]
        {
            TimeSpanParser.Examples.SixMonths,              // "6M"
            TimeSpanParser.Examples.OneAndHalfYears,        // "1.5Y"
            TimeSpanParser.Examples.OneYearSixMonths,       // "1Y6M"
            TimeSpanParser.Examples.TwoWeeksThreeDays,      // "2W3D"
            TimeSpanParser.Examples.ThreeMonthsTwoWeeks,    // "3M2W"
            TimeSpanParser.Examples.OneYearTwoMonthsFiveDays // "1Y2M5D"
        };
        
        foreach (var format in exampleFormats)
        {
            var duration = TimeSpanParser.Parse(format);
            Console.WriteLine($"{format} = {duration.TotalDays:F1} days");
        }
    }
    
    public void DocumentationExample()
    {
        const string helpText = 
            "Supported duration formats:\n" +
            $"  - {TimeSpanParser.Examples.SixMonths} (6 months)\n" +
            $"  - {TimeSpanParser.Examples.OneAndHalfYears} (1.5 years)\n" +
            $"  - {TimeSpanParser.Examples.OneYearSixMonths} (1 year 6 months)\n" +
            $"  - {TimeSpanParser.Examples.TwoWeeksThreeDays} (2 weeks 3 days)";
        
        Console.WriteLine(helpText);
    }
}
```

## ðŸ”§ Troubleshooting

### Common Issues

**1. Incorrect Unit Ordering**

```csharp
// âœ— Problem: Units out of order
try
{
    var wrong = TimeSpanParser.Parse("6M1Y"); // Months before years
}
catch (ArgumentException ex)
{
    // "Invalid duration expression: 6M1Y"
}

// âœ“ Solution: Use correct ordering (Y, M, W, D, H, m, S)
var correct = TimeSpanParser.Parse("1Y6M");
```

**2. Confusing Minutes and Months**

```csharp
// Be careful with case sensitivity!
var sixMonths = TimeSpanParser.Parse("6M");   // 6 MONTHS (~183 days)
var sixMinutes = TimeSpanParser.Parse("6m");  // 6 MINUTES (0.0042 days)

Console.WriteLine($"6M = {sixMonths.TotalDays:F1} days");    // ~182.6
Console.WriteLine($"6m = {sixMinutes.TotalMinutes:F1} min"); // 6.0

// âœ“ Best practice: Be explicit
var minutes = TimeSpanParser.Parse("360m");   // 6 hours in minutes
var months = TimeSpanParser.Parse("6M");      // 6 months
```

**3. Unexpected Precision with Approximate Calculations**

```csharp
// Problem: Using Parse for date-sensitive calculations
var subscription = DateTime.UtcNow;
var approxExpiry = subscription + TimeSpanParser.Parse("1M");
// Uses ~30.44 days, may not align with actual month end

// Solution: Use GetExpressionOccurrence for calendar accuracy
var exactExpiry = TimeSpanParser.GetExpressionOccurrence(
    DateTimeOffset.UtcNow, 
    "1M", 
    1
);
// Properly handles month boundaries
```

### Parsing Errors

Handle parsing errors gracefully:

```csharp
public class ErrorHandling
{
    public TimeSpan ParseWithFallback(string expression, TimeSpan fallback)
    {
        if (!TimeSpanParser.TryParse(expression, out var result))
        {
            _logger.LogWarning(
                "Failed to parse duration '{Expression}', using fallback: {Fallback}", 
                expression, 
                fallback
            );
            return fallback;
        }
        return result;
    }
    
    public void ValidateFormat(string expression)
    {
        try
        {
            TimeSpanParser.Parse(expression);
        }
        catch (ArgumentException ex)
        {
            // Provide helpful error message
            throw new ArgumentException(
                $"Invalid duration format: '{expression}'. " +
                $"Expected format: [Y][M][W][D][H][m][S] " +
                $"(e.g., '6M', '1.5Y', '2W3D'). " +
                $"Original error: {ex.Message}",
                nameof(expression),
                ex
            );
        }
    }
}
```

### Precision Considerations

Understand the precision differences:

```csharp
public class PrecisionDemo
{
    public void ComparePrecision()
    {
        var referenceDate = new DateTimeOffset(2024, 1, 15, 0, 0, 0, TimeSpan.Zero);
        
        // Approximate calculation
        var approxDuration = TimeSpanParser.Parse("3M");
        var approxDate = referenceDate - approxDuration;
        Console.WriteLine($"Approximate: {approxDate:yyyy-MM-dd}");
        // Uses 30.44 * 3 = ~91.3 days
        
        // Calendar-accurate calculation
        var exactDate = TimeSpanParser.GetExpressionOccurrence(referenceDate, "3M", 1);
        Console.WriteLine($"Exact: {exactDate:yyyy-MM-dd}");
        // Uses actual calendar months
        
        // Difference can be significant
        var difference = approxDate - exactDate;
        Console.WriteLine($"Difference: {difference.TotalDays:F1} days");
    }
    
    public void LeapYearConsiderations()
    {
        var leapYearDate = new DateTimeOffset(2024, 2, 29, 0, 0, 0, TimeSpan.Zero);
        
        // Adding 1 year to Feb 29 (leap year)
        var nextYear = TimeSpanParser.GetExpressionOccurrence(leapYearDate, "1Y", 1);
        // Result: Feb 28, 2023 (not a leap year)
        
        Console.WriteLine($"One year before {leapYearDate:yyyy-MM-dd} is {nextYear:yyyy-MM-dd}");
    }
}
```

## ðŸ“š Reference

### Classes

- **`TimeSpanParser`**: Static class providing duration parsing functionality
- **`TimeSpanParser.Examples`**: Static class containing predefined example constants

### Methods

#### Parse

```csharp
public static TimeSpan Parse(string expression)
```

Parses an extended TimeSpan expression into a `TimeSpan` using approximate conversions.

**Parameters:**
- `expression` (string): Duration expression (e.g., "6M", "1.5Y", "2W3D") or standard TimeSpan format. If null/whitespace, returns `DefaultPeriod`.

**Returns:** `TimeSpan` representing the approximate duration.

**Exceptions:** 
- `ArgumentException`: Invalid expression format.

**Example:**
```csharp
var duration = TimeSpanParser.Parse("6M");
var standard = TimeSpanParser.Parse("01:30:00");
```

#### TryParse

```csharp
public static bool TryParse(string expression, out TimeSpan result)
```

Attempts to parse an extended TimeSpan expression without throwing exceptions.

**Parameters:**
- `expression` (string): Duration expression to parse.
- `result` (out TimeSpan): Parsed TimeSpan if successful, otherwise `TimeSpan.Zero`.

**Returns:** `true` if parsing succeeded, otherwise `false`.

**Example:**
```csharp
if (TimeSpanParser.TryParse("6M", out var duration))
{
    Console.WriteLine($"Parsed: {duration.TotalDays} days");
}
```

#### GetExpressionOccurrence

```csharp
public static DateTimeOffset GetExpressionOccurrence(
    DateTimeOffset referenceDate, 
    string expression, 
    int occurrence)
```

Calculates a date/time by applying a duration expression to a reference date using calendar-accurate operations.

**Parameters:**
- `referenceDate` (DateTimeOffset): Starting date/time.
- `expression` (string): Duration expression. If null/whitespace, uses `DefaultPeriod`.
- `occurrence` (int): Multiplier for the expression (currently not implemented in method body).

**Returns:** `DateTimeOffset` representing the calculated date (duration is subtracted from reference date).

**Exceptions:** 
- `ArgumentException`: Invalid expression format.

**Example:**
```csharp
var today = DateTimeOffset.UtcNow;
var sixMonthsAgo = TimeSpanParser.GetExpressionOccurrence(today, "6M", 1);
```

### Constants

#### DefaultPeriod

```csharp
public const string DefaultPeriod = "1M";
```

Default duration period used when no expression is provided (1 month).

#### Example Constants

```csharp
public static class Examples
{
    public const string SixMonths = "6M";
    public const string OneAndHalfYears = "1.5Y";
    public const string SixWeeks = "6W";
    public const string OneYearSixMonths = "1Y6M";
    public const string TwoWeeksThreeDays = "2W3D";
    public const string ThreeMonthsTwoWeeks = "3M2W";
    public const string OneYearTwoMonthsFiveDays = "1Y2M5D";
}
```

### Expression Format

The parser uses a compiled regular expression to validate and parse expressions:

```regex
^(?:(\d+(?:\.\d+)?)Y)?(?:(\d+(?:\.\d+)?)M)?(?:(\d+(?:\.\d+)?)W)?(?:(\d+(?:\.\d+)?)D)?(?:(\d+(?:\.\d+)?)H)?(?:(\d+(?:\.\d+)?)m)?(?:(\d+(?:\.\d+)?)S)?$
```

**Format Rules:**
- All units are optional
- Units must appear in order: Y, M, W, D, H, m, S
- Fractional values supported (e.g., "1.5Y")
- Case-insensitive parsing (except lowercase 'm' for minutes)
- No spaces between components

**Valid Examples:**
- `6M` - 6 months
- `1.5Y` - 1.5 years
- `2W3D` - 2 weeks and 3 days
- `1Y6M2W1D12H30m45S` - All units combined

**Invalid Examples:**
- `6M 2W` - Contains space
- `M6` - Missing number
- `6M1Y` - Wrong order
- `1.5.5Y` - Invalid decimal format

## ðŸ’¡ Best Practices

### Choosing Parse vs GetExpressionOccurrence

**Use `Parse` when:**
- You need a duration for comparison or calculation
- Working with timeouts, delays, or intervals
- Precision of days doesn't matter (approximate is fine)
- Storing duration values in configuration
- Calculating elapsed time thresholds

```csharp
// Good use of Parse
public bool IsDataStale(DateTime lastUpdate, string freshnessThreshold)
{
    var threshold = TimeSpanParser.Parse(freshnessThreshold);
    return DateTime.UtcNow - lastUpdate > threshold;
}

public async Task<T> GetWithTimeoutAsync<T>(string timeoutExpression)
{
    var timeout = TimeSpanParser.Parse(timeoutExpression);
    using var cts = new CancellationTokenSource(timeout);
    return await FetchDataAsync(cts.Token);
}
```

**Use `GetExpressionOccurrence` when:**
- Calculating subscription renewals or billing dates
- Working with month-end or year-end dates
- Need exact calendar arithmetic
- Dealing with user-facing date displays
- Compliance or audit requirements need precision

```csharp
// Good use of GetExpressionOccurrence
public DateTimeOffset CalculateNextBillingDate(
    DateTimeOffset subscriptionStart, 
    string billingCycle)
{
    return TimeSpanParser.GetExpressionOccurrence(
        subscriptionStart, 
        billingCycle, 
        1
    );
}

public DateTimeOffset GetContractEndDate(
    DateTimeOffset startDate, 
    string contractTerm)
{
    return TimeSpanParser.GetExpressionOccurrence(
        startDate, 
        contractTerm, 
        1
    );
}
```

### Handling User Input

Always validate and sanitize user-provided duration expressions:

```csharp
public class UserInputValidator
{
    private static readonly string[] AllowedFormats = 
    {
        TimeSpanParser.Examples.SixMonths,
        TimeSpanParser.Examples.OneYearSixMonths,
        TimeSpanParser.Examples.TwoWeeksThreeDays
    };
    
    public TimeSpan ParseUserDuration(string userInput)
    {
        // Trim whitespace
        var cleaned = userInput?.Trim();
        
        // Validate not empty
        if (string.IsNullOrEmpty(cleaned))
        {
            throw new ArgumentException("Duration cannot be empty");
        }
        
        // Try parse with validation
        if (!TimeSpanParser.TryParse(cleaned, out var result))
        {
            throw new ArgumentException(
                $"Invalid duration format: '{userInput}'. " +
                $"Examples: {string.Join(", ", AllowedFormats)}"
            );
        }
        
        // Business rule validation
        if (result < TimeSpan.FromDays(1))
        {
            throw new ArgumentException("Duration must be at least 1 day");
        }
        
        if (result > TimeSpan.FromDays(3650)) // ~10 years
        {
            throw new ArgumentException("Duration cannot exceed 10 years");
        }
        
        return result;
    }
    
    public string SuggestCorrection(string invalidInput)
    {
        // Provide helpful suggestions for common mistakes
        if (invalidInput.Contains(" "))
            return "Remove spaces between units";
        
        if (Regex.IsMatch(invalidInput, @"\d+[a-z]", RegexOptions.IgnoreCase))
            return "Use uppercase for units (Y, M, W, D, H) except minutes (m)";
        
        return "Use format like '6M', '1Y', or '2W3D'";
    }
}
```

### Precision Requirements

Document your precision requirements clearly:

```csharp
/// <summary>
/// Retention policy using approximate duration calculations.
/// Note: Uses average month length (30.44 days) for simplicity.
/// Suitable for data retention where exact day count is not critical.
/// </summary>
public class DataRetentionPolicy
{
    private readonly TimeSpan _retentionPeriod;
    
    public DataRetentionPolicy(string retentionExpression)
    {
        // Approximate calculation is acceptable here
        _retentionPeriod = TimeSpanParser.Parse(retentionExpression);
    }
    
    public bool ShouldRetain(DateTime createdDate)
    {
        return DateTime.UtcNow - createdDate <= _retentionPeriod;
    }
}

/// <summary>
/// Subscription billing using calendar-accurate date calculations.
/// Note: Uses exact calendar months to ensure bills align with
/// month boundaries regardless of month length or leap years.
/// </summary>
public class BillingSchedule
{
    private readonly string _billingCycle;
    
    public BillingSchedule(string billingCycle)
    {
        _billingCycle = billingCycle;
    }
    
    public DateTimeOffset GetNextBillingDate(DateTimeOffset lastBillingDate)
    {
        // Calendar-accurate calculation required for billing
        return TimeSpanParser.GetExpressionOccurrence(
            lastBillingDate, 
            _billingCycle, 
            1
        );
    }
}
```

### Configuration Best Practices

Store duration expressions in configuration for flexibility:

```json
{
  "DataRetention": {
    "ShortTerm": "30D",
    "MediumTerm": "6M",
    "LongTerm": "2Y"
  },
  "Subscription": {
    "Trial": "2W",
    "Monthly": "1M",
    "Quarterly": "3M",
    "Annual": "1Y"
  },
  "Cache": {
    "FastExpiry": "5m",
    "SlowExpiry": "1H",
    "DailyExpiry": "1D"
  }
}
```

```csharp
public class DurationConfiguration
{
    public string ShortTerm { get; set; } = "30D";
    public string MediumTerm { get; set; } = "6M";
    public string LongTerm { get; set; } = "2Y";
}

public class RetentionService
{
    private readonly DurationConfiguration _config;
    
    public RetentionService(IOptions<DurationConfiguration> config)
    {
        _config = config.Value;
    }
    
    public TimeSpan GetRetentionPeriod(RetentionLevel level)
    {
        var expression = level switch
        {
            RetentionLevel.Short => _config.ShortTerm,
            RetentionLevel.Medium => _config.MediumTerm,
            RetentionLevel.Long => _config.LongTerm,
            _ => TimeSpanParser.DefaultPeriod
        };
        
        return TimeSpanParser.Parse(expression);
    }
}
```

**Key Guidelines:**
- Use `Parse` for approximate durations and timeouts
- Use `GetExpressionOccurrence` for calendar-accurate date calculations
- Always validate user input with `TryParse`
- Document precision requirements in your code
- Store expressions in configuration for flexibility
- Be explicit about case sensitivity (uppercase for units except 'm' for minutes)
- Provide clear error messages with format examples
- Consider business rule validation beyond format validation
